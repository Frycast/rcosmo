# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#'@title covCMB_internal1
#'
#'
#'see \code{\link{CMBDataFrame}}
#'
#'@name covCMB_internal1
#'
covCMB_internal1 <- function(cmbdf, breaks) {
    .Call('_rcosmo_covCMB_internal1', PACKAGE = 'rcosmo', cmbdf, breaks)
}

#'@title
#'covCMB_internal2
#'
#'
#'This function acknowledges that there is no need to transform with acos.
#'The breaks are cos(r_i) where r_i is the radius.
#'The bins will have equal area provided that cos(r_i) - cos(r_{i+1}) is fixed.
#'Alternatively, the bins will have equal annular width if r_{i+1} - r_i is fixed,
#'but cos(r_i) must be passed in, regardless of which
#'metric is used to fix distance beforehand.
#'We must note that: For r in (0,pi), cos is a strictly decreasing function,
#'e.g. cos(0) > cos(max.dist)
#'
#'
#'
#'@name covCMB_internal2
#'
covCMB_internal2 <- function(cmbdf, cos_breaks) {
    .Call('_rcosmo_covCMB_internal2', PACKAGE = 'rcosmo', cmbdf, cos_breaks)
}

mkpix2xyC <- function(nside = 1024L) {
    .Call('_rcosmo_mkpix2xyC', PACKAGE = 'rcosmo', nside)
}

#' @title nest2ring
#'
#' @description
#' Convert from "nested" to "ring" ordering
#'
#' \code{nest2ring} computes the HEALPix pixel index
#' in the "ring" ordering scheme from the pixel index
#' in the "nested" ordering scheme.
#'
#' @param nside is the HEALPix nside parameter.
#'
#' @param pix is the set or subset of pixel indices at nside.
#' If pix is left blank then all pixels are converted.
#'
#' @return the output is the corresponding set of pixel in
#' the ring ordering scheme.
#'
#' @example
#' # compute HEALPix indices in the ring ordering scheme
#' nside <- 8
#' pix <-c(1,2,23)
#' nest2ring(nside,pix)
#'
#' @name nest2ring
#' @export
nest2ring <- function(nside, pix) {
    .Call('_rcosmo_nest2ring', PACKAGE = 'rcosmo', nside, pix)
}

#'@title
#'pix2coords_internal
#'@description
#'Converts HEALPix pixel scheme to spherical or
#'Cartesian coordinates.
#'
#'@param nside The number of cuts to a HEALPix base resolution pixel.
#'@param nested Set to TRUE for NESTED ordering scheme and FALSE for RING.
#'@param spix Optional integer or vector of sample pixel indices.
#'@param cartesian Set to FALSE to output spherical coordinates
#'or else TRUE for cartesian.
#'
#'@details
#'This is a place holder
#'
#'@return A matrix with columns theta and phi (in that order), or
#' x, y, z (if cartesian = TRUE). Theta (in [0,pi]) is the colatitude
#' in radians measured from the North Pole and phi (in [0, 2*pi])
#' is the longitude in radians measured Eastward. The remaining 3 columns
#' returned are i, j, and p which represent the HEALPix ring index,
#' pixel-in-ring index, and pixel index respectively.
#'
#'@name pix2coords_internal
#'
pix2coords_internal <- function(nside = 0L, nested = TRUE, spix = NULL, cartesian = FALSE) {
    .Call('_rcosmo_pix2coords_internal', PACKAGE = 'rcosmo', nside, nested, spix, cartesian)
}

#'@title
#'car2sph
#'
#'@param df a data.frame with columns labelled x, y and z
#'
#'@return a data.frame with columns theta and phi for colatitude and
#'longitude in ranges \eqn{[0,pi]} and \eqn{[0,2pi]} respectively
#'
#'@name car2sph
#'
car2sph <- function(df) {
    .Call('_rcosmo_car2sph', PACKAGE = 'rcosmo', df)
}

#'@title
#'sph2car
#'
#'@param df a data.frame with columns labelled \code{theta} and \code{phi}
#'for colatitude and longitude respectively
#'
#'@return a data.frame with columns x, y, z (cartesian coordinates)
#'
#'@name sph2car
#'
sph2car <- function(df) {
    .Call('_rcosmo_sph2car', PACKAGE = 'rcosmo', df)
}

#'@title
#'pointInConvexPolygonHP
#'
#'@param nside the nside parameter at which to find pixels
#'@param nested Set to TRUE for NESTED ordering scheme and FALSE for RING
#'@param win a data.frame with columns x, y, z for cartesian coordinates
#'The rows represent clockwise oriented vertices of a convex spherical
#'polygon that lies entirely within one open hemisphere of the unit sphere
#'@param spix Optional integer or vector of sample pixel indices. If \code{spix}
#'is unspecified then all pixels at \code{nside} are used
#'
#'@return a logical vector indicated which pixels in \code{spix}
#'lie within the spherical convex polygon determined by \code{win}
#'
#'@name pointInConvexPolygonHP
#'
pointInConvexPolygonHP <- function(nside, nested, win, spix = NULL) {
    .Call('_rcosmo_pointInConvexPolygonHP', PACKAGE = 'rcosmo', nside, nested, win, spix)
}

#'@title
#'pointInDiscHP
#'
#'@param nside the nside parameter at which to find pixels
#'@param nested Set to TRUE for NESTED ordering scheme and FALSE for RING
#'@param win a data.frame with columns x, y, z for the cartesian coordinates
#'of a point on the unit sphere, representing a disc center, and column r for
#'the radius or that disc
#'@param spix Optional integer or vector of sample pixel indices. If \code{spix}
#'is unspecified then all pixels at \code{nside} are used
#'
#'@return a logical vector indicated which pixels in \code{spix}
#'lie within the spherical disc determined by \code{win}
#'
#'@name pointInDiscHP
#'
pointInDiscHP <- function(nside, nested, win, spix = NULL) {
    .Call('_rcosmo_pointInDiscHP', PACKAGE = 'rcosmo', nside, nested, win, spix)
}

#'@title
#'pointInConvexPolygon
#'
#'@param df a data.frame with columns x, y, z for cartesian coordinates.
#'The rows represent points on the surface of a unit sphere
#'@param win a data.frame with columns x, y, z for cartesian coordinates.
#'The rows represent clockwise oriented vertices of a convex spherical
#'polygon that lies entirely within one open hemisphere of the unit sphere.
#'
#'@return a logical vector indicated which rows of \code{df}
#'lie within the spherical convex polygon determined by \code{win}
#'
#'@name pointInConvexPolygon
#'
pointInConvexPolygon <- function(df, win) {
    .Call('_rcosmo_pointInConvexPolygon', PACKAGE = 'rcosmo', df, win)
}

#'@title
#'pointInDisc
#'
#'@param df a data.frame with columns x, y, z for cartesian coordinates.
#'The rows represent points on the surface of a unit sphere
#'@param win a data.frame with columns x, y, z for the cartesian coordinates
#'of a point on the unit sphere, representing a disc center, and column r for
#'the radius or that disc.
#'
#'@return a logical vector indicated which rows of \code{df}
#'lie within the spherical disc determined by \code{win}
#'
#'@name pointInDisc
#'
pointInDisc <- function(df, win) {
    .Call('_rcosmo_pointInDisc', PACKAGE = 'rcosmo', df, win)
}

#'@title
#'maxDist_internal
#'
#'@param cmbdf a \code{data.frame} or \code{\link{CMBDataFrame}}
#'
#'@return the maximum distance between any of the
#'points in \code{cmbdf}
#'
#'@name maxDist_internal
#'
maxDist_internal <- function(cmbdf) {
    .Call('_rcosmo_maxDist_internal', PACKAGE = 'rcosmo', cmbdf)
}

#'@title
#'minDist
#'
#'@param cmbdf a \code{data.frame} or \code{\link{CMBDataFrame}}
#'@param point a point on the unit sphere in cartesian coordinates
#'
#'@return the shortest distance from \code{point} to \code{cmbdf}
#'
#'@name minDist
#'
#'@export
minDist <- function(cmbdf, point) {
    .Call('_rcosmo_minDist', PACKAGE = 'rcosmo', cmbdf, point)
}

