# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#'@title
#'pointInConvexPolygon
#'
#'@param df a data.frame with columns x, y, z for cartesian coordinates.
#'The rows represent points on the surface of a unit sphere
#'@param win a data.frame with columns x, y, z for cartesian coordinates.
#'The rows represent clockwise oriented vertices of a convex spherical
#'polygon that lies entirely within one open hemisphere of the unit sphere.
#'
#'@return a logical vector indicated which rows of \code{df}
#'lie within the spherical convex polygon determined by \code{win}
#'
#'@name pointInConvexPolygon
#'
#'@export
pointInConvexPolygon <- function(df, win) {
    .Call('_rcosmo_pointInConvexPolygon', PACKAGE = 'rcosmo', df, win)
}

#'@title
#'pointInDisc
#'
#'@param df a data.frame with columns x, y, z for cartesian coordinates.
#'The rows represent points on the surface of a unit sphere
#'@param win a data.frame with columns x, y, z for the cartesian coordinates
#'of a point on the unit sphere, representing a disc center, and column r for
#'the radius or that disc.
#'
#'@return a logical vector indicated which rows of \code{df}
#'lie within the spherical disc determined by \code{win}
#'
#'@name pointInDisc
#'
#'@export
pointInDisc <- function(df, win) {
    .Call('_rcosmo_pointInDisc', PACKAGE = 'rcosmo', df, win)
}

mkpix2xyC <- function(nside = 1024L) {
    .Call('_rcosmo_mkpix2xyC', PACKAGE = 'rcosmo', nside)
}

#' @title nest2ring
#'
#' @description
#' Convert from "nested" to "ring" ordering
#'
#' \code{nest2ring} computes the HEALPix pixel index
#' in the "ring" ordering scheme from the pixel index
#' in the "nested" ordering scheme.
#'
#' @param nside is the HEALPix nside parameter.
#'
#' @param pix is the set or subset of pixel indices at nside.
#'
#' @return the output is the corresponding set of pixel in
#' the ring ordering scheme.
#'
#' @example
#' # compute HEALPix indices in the ring ordering scheme
#' nside <- 8
#' pix <-c(1,2,23)
#' nest2ring(nside,pix)
#'
#' @name nest2ring
#' @export
nest2ring <- function(nside, pix) {
    .Call('_rcosmo_nest2ring', PACKAGE = 'rcosmo', nside, pix)
}

#'@title
#'pix2coords
#'@description
#'Converts HEALPix pixel scheme to spherical or
#'Cartesian coordinates.
#'
#'@param nside The number of cuts to a HEALPix base resolution pixel.
#'@param nested Set to TRUE for NESTED ordering scheme and FALSE for RING.
#'@param spix Optional integer or vector of sample pixel indices.
#'@param cartesian Set to FALSE to output spherical coordinates
#'or else TRUE for cartesian.
#'
#'@details
#'This is a place holder
#'
#'@return A matrix with columns theta and phi (in that order), or
#' x, y, z (if cartesian = TRUE). Theta (in [0,pi]) is the colatitude
#' in radians measured from the North Pole and phi (in [0, 2*pi])
#' is the longitude in radians measured Eastward. The remaining 3 columns
#' returned are i, j, and p which represent the HEALPix ring index,
#' pixel-in-ring index, and pixel index respectively.
#'
#'@name pix2coords
#'
#' @export
pix2coords <- function(nside = 0L, nested = TRUE, spix = NULL, cartesian = FALSE) {
    .Call('_rcosmo_pix2coords', PACKAGE = 'rcosmo', nside, nested, spix, cartesian)
}

#'@title
#'geoDistList
#'@description
#'Create a list of all geodesic distances between points on the unit
#'sphere corresponding to the rows of the data.frame cmbdf.
#'
#'@param cmbdf a data.frame whose first 3 columns represent the cartesian
#'coordinates x,y,z of nrow(cmbdf) points on a unit sphere.
#'
#'@return
#'Let \eqn{x_i, x_j} be the points represented by row i and row j of
#'cmbdf, where i < j, and let L denote the output list
#'\code{L <- geoDistList(cmbdf)}. Then the distance \eqn{d(x_i,x_j)}
#'is stored in \code{L[[i]][j-i]}.
#'
#'@name geoDistList
#'
#'@export
geoDistList <- function(cmbdf) {
    .Call('_rcosmo_geoDistList', PACKAGE = 'rcosmo', cmbdf)
}

#'@title
#'distBinList
#'@description
#'Find all geodesic distances between points on the unit
#'sphere corresponding to the rows of the data.frame cmbdf,
#'then categorise these distances according to the intervals
#'given by the breaks argument.
#'
#'@param cmbdf a data.frame whose first 3 columns represent the cartesian
#'coordinates x,y,z of nrow(cmbdf) points on a unit sphere.
#'@param breaks a vector, sorted from lowest to highest,
#'specifying the break points for the intervals that are
#'used to categorise the geodesic distances. The intervals are
#'open at left and closed at right.
#'
#'@return
#'Let \eqn{x_i, x_j} be the points represented by row i and row j of
#'cmbdf, where\eqn{i < j}, and let \eqn{L} denote the output list
#'\code{L <- distBinList(cmbdf, breaks)}. Suppose the distance
#'\eqn{d(x_i,x_j)} falls into the \eqn{k^{th}} interval determined
#'by \code{breaks}, then \code{L[[i]][j-i]} will hold the value \eqn{k}.
#'
#'@name distBinList
#'
#'@export
distBinList <- function(cmbdf, breaks) {
    .Call('_rcosmo_distBinList', PACKAGE = 'rcosmo', cmbdf, breaks)
}

#'@title
#'covCMB_internal1
#'
#'@name covCMB_internal1
#'
#'@export
covCMB_internal1 <- function(cmbdf, breaks) {
    .Call('_rcosmo_covCMB_internal1', PACKAGE = 'rcosmo', cmbdf, breaks)
}

#'@title
#'covCMB_internal2
#'
#'@name covCMB_internal2
#'
#'@export
covCMB_internal2 <- function(cmbdf, nbin) {
    .Call('_rcosmo_covCMB_internal2', PACKAGE = 'rcosmo', cmbdf, nbin)
}

#'@title
#'car2sph
#'
#'@param df a data.frame with columns labelled x, y and z
#'
#'@return a data.frame with columns theta and phi for colatitude and
#'longitude in ranges \eqn{[0,pi]} and \eqn{[0,2pi]} respectively
#'
#'@name car2sph
#'
#'@export
car2sph <- function(df) {
    .Call('_rcosmo_car2sph', PACKAGE = 'rcosmo', df)
}

#'@title
#'sph2car
#'
#'@param df a data.frame with columns labelled \code{theta} and \code{phi}
#'for colatitude and longitude respectively
#'
#'@return a data.frame with columns x, y, z (cartesian coordinates)
#'
#'@name sph2car
#'
#'@export
sph2car <- function(df) {
    .Call('_rcosmo_sph2car', PACKAGE = 'rcosmo', df)
}

