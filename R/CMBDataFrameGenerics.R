
#' Coordinate system from a CMBDataFrame
#'
#' This function returns the coordinate system used in a CMBDataFrame.
#' The coordinate system is either "cartesian" or "spherical"
#'
#' If a new coordinate system is specified, using e.g. new.coords = "spherical", the
#' coordinate system of the CMBDataFrame will be converted.
#'
#'@param cmbdf a CMBDataFrame.
#'@param new.coords specifies the new coordinate system ("spherical" or "cartesian")
#'if a change of coordinate system is desired.
#'
#'@return
#' If new.coords is unspecified, then the name of the coordinate system
#' of \code{cmbdf} is returned. Otherwise a new CMBDataFrame is returned
#' equivalent to \code{cmbdf} but having the desired change of coordinates
#'
#'@examples
#' df <- CMBDataFrame("CMB_map_smica1024.fits", sample.size = 800000)
#' coords(df)
#' coords(df, new.coords = "cartesian")
#'
#'@export
coords.CMBDataFrame <- function( cmbdf, new.coords )
{
  # If new.coords argument is missing then return the coordinate type
  if ( missing(new.coords) )
  {
    return(attr(cmbdf, "coords"))
  }
  else
  {
    new.coords <- as.character(tolower(new.coords))

    # Make sure that new.coords doesn't match current coords
    if ( !is.null(attr(cmbdf, "coords"))
         && attr(cmbdf, "coords") == new.coords )
    {
      # Nothing to do
    }
    else if ( new.coords == "spherical" )
    {
      # Convert to spherical
      n <- ncol(cmbdf)
      other.names <- names(cmbdf)[-c(which(names(cmbdf) == "x"),
                                     which(names(cmbdf) == "y"),
                                     which(names(cmbdf) == "z"))]

      xyz <- cmbdf[,c("x", "y", "z")]
      others <- cmbdf[, other.names]

      cmbdf[,1:2] <- car2sph(xyz)
      cmbdf[,3:(n-1)] <- others
      cmbdf[,n] <- NULL
      names(cmbdf) <- c("lat", "long", other.names)
    }
    else if ( new.coords == "cartesian" )
    {
      # convert to cartesian

      n <- ncol(cmbdf)
      other.names <- names(cmbdf)[-c(which(names(cmbdf) == "lat"),
                                     which(names(cmbdf) == "long"))]

      sph <- cmbdf[,c("lat", "long")]
      others <- cmbdf[, other.names]

      cmbdf[,1:3] <- sph2car(sph)
      cmbdf[,4:(n+1)] <- others
      names(cmbdf) <- c("x","y","z", other.names)
    }

    attr(cmbdf, "coords") <- new.coords
    return(cmbdf)
  }
}



#' Assign new coordinate system to CMBDataFrame
#' @export
`coords<-.CMBDataFrame` <- function(cmbdf,...,value) {
  value <- tolower(value)
  if (coords(cmbdf) == value)
  {

    return(cmbdf)
  } else {

    return(coords(cmbdf, new.coords = value))
  }
}








#### CURRENTLY THE DATA USED IN THE PLOT FUNCTION IS TOO LARGE FOR CRAN ##
#' Plot CMB Data
#'
#' This function produces a plot from a CMB Data Frame.
#'
#'@param cmbdf a CMB Data Frame with either spherical or cartesian coordinates.
#'@param add if TRUE then this plot will be added to any existing plot
#'@param sample.size optionally specifies the size of a simple random
#'sample to take before plotting. This can make the plot less
#'computationally intensive
#'
#'@return
#'A plot of the CMB data
#'
#'@examples
#' df <- CMBDataFrame("CMB_map_smica1024.fits")
#' plot(df, sample.size = 800000)
#'
#'@export
plot.CMBDataFrame <- function(cmbdf, add = FALSE, sample.size, ...)
{

  if ( nside(cmbdf) == 1024 )
  {
    if ( missing(sample.size) )
    {
      cols <- CMBcols1024 # internal data generated by data-raw/ColourMap.R
    } else {
      spix <- sample(pix(cmbdf), sample.size)
      cmbdf <- cmbdf[spix,]
      cols <- CMBcols1024[spix]
    }

    warning(paste("(development stage) the colour map for",
            "nside = 1024 may not be ideal"))

  } else if ( nside(cmbdf) == 2048 ) {

    ## The following code must be replaced to work with nside = 2048
    if ( missing(sample.size) )
    {
      cols <- CMBcols1024 # internal data generated by data-raw/ColourMap.R
    } else {
      spix <- sample(pix(cmbdf), sample.size)
      cmbdf <- cmbdf[spix,]
      cols <- CMBcols1024[spix]
    }

    warning(paste("(development stage) the colour map used was not",
            "generated for nside = 2048"))
  } else {

    cols <- "blue"

  }

  coords <- coords(cmbdf)

  try(if(coords != "spherical" && coords != "cartesian")
    stop("Coordinates must be spherical or cartesian"))

  if (coords == "spherical") {
    cmbdf_xyz <- as.data.frame(sphereplot::sph2car(cmbdf$long,
                                                   cmbdf$lat,
                                                   deg = FALSE))
  } else {
    # Else coords are already cartesian
    cmbdf_xyz <- data.frame(x = cmbdf$x, y = cmbdf$y, z = cmbdf$z)
  }

  rgl::open3d()
  rgl::bg3d("black")
  rgl::plot3d(cmbdf_xyz, col = cols, type = "p", cex = 5,
              pch = 3, box = FALSE, axes = FALSE, add = add)
}









#' Summarise CMB Data
#'
#' This function produces a summary from a CMB Data Frame.
#'
#'@param cmbdf a CMB Data Frame.
#'
#'@return
#'A summary of the CMB data.
#'
#'@examples
#' df <- CMBDataFrame("CMB_map_smica1024.fits", sample.size = 800000)
#' summary(df)
#'
#'@export
summary.CMBDataFrame <- function(cmbdf)
{
  if ( sum(names(df) == "I") %>% as.numeric() %>% identical(1) )
  {
    ans <- list(intensities = summary(df$I))
  }

  ans[["coords"]] <- ifelse(is.null(coords(cmbdf)),
                            "HEALPix only",coords(cmbdf))
  ans[["ordering"]] <- ordering(cmbdf)
  ans[["nside"]] <- nside(cmbdf)
  ans[["window"]] <- "The CMBWindow class is under development"

  ans
}










#' Print CMB Data
#'
#' This function neatly prints the contents of a CMB Data Frame.
#'
#'@param cmbdf a CMB Data Frame.
#'@param ... arguments passed to \code{\link{print.tbl_df}}
#'
#'@return
#'Prints contents of the CMB data frame to the console.
#'
#'@examples
#' df <- CMBDataFrame("CMB_map_smica1024.fits", sample.size = 800000)
#' print(df)
#' df
#'
#'@export
print.CMBDataFrame <- function(cmbdf,...)
{
  print(tibble::as.tibble(cmbdf),...)
}





